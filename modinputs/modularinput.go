package modinputs

import (
	"encoding/xml"
	"fmt"
	"github.com/google/uuid"
	"os"
	"path"
	"strings"
	"time"
)

// StreamingFunc is the signature of the function used to generate the data for the modular input
type StreamingFunc func(*ModularInput, *Stanza) error

// ValidationFun is the signature of the function used to validate the parameters received from Splunk
// (only used if the mod input is configured to use external validation)
type ValidationFunc func(*ModularInput, *Stanza) error

// ModularInput is the main structure defining how a modular input looks like.
// It provides a way for the user to define a Splunk modular input and makes
// standardised methods available.
type ModularInput struct {
	// Name appearing within inputs.conf stanza as [stanzaname://...].
	// Must be lowercase
	StanzaName string
	// Title displayed on the UI
	Title string
	// Description within the UI
	Description           string
	UseExternalValidation bool
	UseSingleInstance     bool
	Args                  []InputArg
	// (optional) function used to validate data. Expected only if the modular input is configured to use "external validation"
	Validate ValidationFunc
	// function used to stream generated data
	Stream StreamingFunc

	// This debug setting is meant for facilitating development and is not configurable by a user through splunk's inputs.conf
	debug bool

	// These parameters are read-in from the XML-based configurations provided on stdin by splunk upon execution
	hostname      string
	uri           string
	sessionKey    string
	checkpointDir string
	stanzas       []Stanza
	// Unique id of this run, generated when starting the "Run" function
	runID string
	// private variables
	internalLogEvent               *SplunkEvent //this is used to setup a standardized event using for logging to index=_internal. If this is not nil, internal loggin is performed through SplunkEvents written on Stdout instead of plain output on Stderr
	cntDataEventsGeneratedbyStanza int64        // counter of data events emitted by the stanza being currently processed (internal loggin is excluded)
	cntDataEventsGeneratedTotal    int64        // counter of data events emitted in total (internal loggin is excluded)
}

func (mi *ModularInput) EnableDebug() {
	mi.debug = true
}

// AddArgument adds a NEW argument to the modular input.
// The argument is additionally returned for further processing, if needed.
func (mi *ModularInput) AddArgument(name, title, description, dataType, validation string, requiredOnCreate, requiredOnEdit bool) (*InputArg, error) {
	if name == "" {
		return nil, fmt.Errorf("Invalid modular input argument defined: 'name' cannot be empty.")
	}
	if title == "" {
		return nil, fmt.Errorf("Invalid modular input argument defined: 'title' cannot be empty.")
	}
	if dataType != ArgDataTypeStr && dataType != ArgDataTypeBool && dataType != ArgDataTypeNumber {
		return nil, fmt.Errorf("Invalid modular input argument defined: 'dataType' provided '%s', expected one of '%s/%s/%s'", dataType, ArgDataTypeStr, ArgDataTypeBool, ArgDataTypeNumber)
	}

	arg := InputArg{
		Title:            title,
		Description:      description,
		Name:             name,
		DataType:         dataType,
		Validation:       validation,
		RequiredOnCreate: requiredOnCreate,
		RequiredOnEdit:   requiredOnEdit,
	}

	mi.Args = append(mi.Args, arg)
	return &arg, nil
}

// Log writes a log so that it can be read by Splunk without being interpreted as an actual event generated by the script
// Argument 'message' can use formatting markers as fmt.Sprintf. Aditional arguments 'a' will be provided to fmt.Sprintf
func (mi *ModularInput) Log(level string, message string, a ...interface{}) (err error) {
	level = strings.ToUpper(level)
	if level == "WARNING" {
		// Typical error, just manage it...
		level = "WARN"
	}
	if level != "DEBUG" && level != "INFO" && level != "WARN" && level != "ERROR" && level != "FATAL" {
		fmt.Fprintf(os.Stderr, "ERROR - ModularInput.Log invoked with invalid level parameter. Accepted: DEBUG, INFO, WARN, ERROR, FATAL. Provided: '%s'\n", level)
		return fmt.Errorf("ModularInput.Log: invalid value of 'level' provided. Accepted: DEBUG, INFO, WARN, ERROR, FATAL. Provided: '%s'", level)
	}
	if level != "DEBUG" || (level == "DEBUG" && mi.debug) {
		// do not do anything if debug is not enabled
		t := time.Now().Round(time.Millisecond)
		if mi.internalLogEvent != nil {
			mi.internalLogEvent.Time = GetEpoch(t)
			// prefix the message with timestamp and log_level
			message = "[" + t.Format("2006-01-02 15:04:05.000 -0700") + "] " + level + " run_id=" + mi.runID + " - " + message
			//time.Format uses a string with such parameters to define the output format: Mon Jan 2 15:04:05 -0700 MST 2006
			mi.internalLogEvent.Data = fmt.Sprintf(message, a...)
			// using writeOut() to skip counting the events, as we do not want to count the internal logs...
			mi.internalLogEvent.writeOut()
		} else {
			// XML-based logging has not yet been activated: using STDERR instead
			message = "ModularInput " + mi.StanzaName + ": " + level + " run_id=" + mi.runID + " - " + message + "\n"
			_, err = fmt.Fprintf(os.Stderr, message, a...)
		}
	}
	return err
}

// WriteToSplunk outputs a generated event in the format accepted by Splunk
// Returns the number of bytes written, an error if anything went wrong
func (mi *ModularInput) WriteToSplunk(se *SplunkEvent) (cnt int, err error) {
	var b []byte
	if b, err = se.xml(); err != nil {
		return -1, err
	}
	// increase the counter of the generated events
	mi.cntDataEventsGeneratedbyStanza++
	mi.cntDataEventsGeneratedTotal++
	cnt, err = os.Stdout.Write(b)
	return cnt, err
}

// NewDefaultEvent provides a template for the SplunkEvent to be used to log actual data to be imported to Splunk
func (mi *ModularInput) NewDefaultEvent(stanza *Stanza) (ev *SplunkEvent) {
	if stanza != nil {
		//mi.Log("DEBUG", fmt.Sprintf("NewDefaultEvent: stanza is NOT nil. %v", stanza.Params))
		// NOT specifying Data intentionally
		ev = &SplunkEvent{
			// Anything can be overridded by the actual script
			Time:       GetEpochNow(),
			Stanza:     stanza.Name,
			SourceType: stanza.Sourcetype(),
			Index:      stanza.Index(),
			Host:       stanza.Host(),
			Source:     stanza.Source(),
			Unbroken:   false,
			Done:       false,
		}
	} else {
		// If no configurations are present, we basically just return a generic event
		ev = &SplunkEvent{
			Time:     GetEpochNow(),
			Unbroken: false,
			Done:     false,
		}
	}
	return ev
}

// Run is the main function that you, as a modular input script developer must invoke to start the actual processing.
func (mi *ModularInput) Run() (err error) {
	mi.runID = uuid.New().String()[0:8]
	mi.Log("DEBUG", "ModularInput.Run started. Cmd-line parameters: '%s'", strings.Join(os.Args, " "))
	if len(os.Args) == 1 {
		// Read XML configs
		// Populates infos about the configuration Stanzas
		if ic, err := getInputConfigFromXML(os.Stdin); err != nil {
			mi.Log("FATAL", "Errow when loading execution configuration XML from StdIn: %s", err.Error())
			return err
		} else {
			mi.Log("DEBUG", "Loaded input configurations: %+v", ic)
			mi.hostname = ic.Hostname
			mi.uri = ic.URI
			mi.sessionKey = ic.SessionKey
			mi.checkpointDir = ic.CheckpointDir
			mi.stanzas = ic.Stanzas
		}
		return mi.runStreaming()
	} else if os.Args[1] == "--scheme" {
		// print a XML definition of the parameters accepted by this modular input
		mi.Log("DEBUG", "starting --scheme action")
		if schemeXml, err := mi.getXMLScheme(); err != nil {
			mi.Log("FATAL", "Error during scheme generation. "+err.Error())
			return err
		} else {
			fmt.Println(schemeXml)
			return nil
		}
	} else if os.Args[1] == "--validate-arguments" {
		// Read XML configs
		if vc, err := getValidationConfigFromXML(os.Stdin); err != nil {
			mi.Log("FATAL", "Errow when loading parameters validation XML from StdIn: %s", err.Error())
			return err
		} else {
			// Assign the loaded configuration to the private vars
			// of the modularinput itself
			mi.Log("DEBUG", "Loaded validation configurations: %+v", vc)
			mi.hostname = vc.Hostname
			mi.uri = vc.URI
			mi.sessionKey = vc.SessionKey
			mi.checkpointDir = vc.CheckpointDir
			//mi.stanzas = []Stanza{*vc.Item.asStanza()}
			mi.stanzas = []Stanza{vc.Item}
		}
		return mi.runValidation()
	} else if os.Args[1] == "--example-config" {
		// This is not part of the standard splunk interface, but it is useful for users to print-out the expected splunk configurations
		fmt.Println(mi.getExampleConf())
		return nil
	} else if os.Args[1] == "-?" || os.Args[1] == "-h" || len(os.Args) >= 2 {
		fmt.Printf(`Usage: %s [--scheme|--validate-arguments|--example-config]
- invoked with no command-line parameters, start the data streaming. Provide configurations on STDIN using the XML format specified at:
		https://docs.splunk.com/Documentation/SplunkCloud/8.1.2011/AdvancedDev/ModInputsScripts#Read_XML_configuration_from_splunkd
- --scheme: prints out the XML scheme definition. See Splunk documentation
- --validate-arguments: validate the parameters provided on STDIN in XML format. See Splunk documentation
- --example-config: Print an example of inputs.conf configuration for this modular input and exit.
`, path.Base(os.Args[0]))
		return nil
	}

	return nil
}

func (mi *ModularInput) runStreaming() (err error) {
	// these two vars are used to track the duration of the overall streaming function
	var duration time.Duration
	mi.Log("DEBUG", "Starting 'runStreaming' function")
	if mi.Stream == nil {
		mi.Log("FATAL", "No streaming function specified")
		return fmt.Errorf("FATAL: no streaming function specified")
	}

	hadErrors := false
	streamingStartTime := time.Now()

	if len(mi.stanzas) == 0 {
		mi.Log("ERROR", "No configurazion stanzas are present within input configuration. Nothing to be done.")
		return fmt.Errorf("ERROR: No input configuration stanzas")
	}

	fmt.Println("<stream>")        // Setup the XML streaming mode
	defer fmt.Println("</stream>") // close XML streaming mode when returning

	for _, stanza := range mi.stanzas {
		// reset the counter of events for the new stanza
		mi.cntDataEventsGeneratedbyStanza = 0
		stanzaStartTime := time.Now()
		//Start logging intenrnal messages as SplunkEvents instead of using plaintext on Stderror
		mi.setupEventBasedInternalLogging(&stanza)
		mi.Log("INFO", `Starting streaming for stanza="%s"`, stanza.Name)
		err = mi.Stream(mi, &stanza)
		duration = time.Now().Sub(stanzaStartTime)
		if err != nil {
			hadErrors = true
			mi.Log("ERROR", `Stanza execution status=failed for stanza="%s" duration_s=%.03f cnt_events=%d error="%s"`, stanza.Name, duration.Seconds(), mi.cntDataEventsGeneratedbyStanza, err.Error())
		} else {
			mi.Log("INFO", `Stanza execution status=succeeded for stanza="%s" duration_s=%.03f cnt_events=%d`, stanza.Name, duration.Seconds(), mi.cntDataEventsGeneratedbyStanza)
		}
	}
	// Remove the stanza-specific logging settings from the event used for internal logging
	if mi.internalLogEvent != nil {
		mi.internalLogEvent.Source = path.Base(os.Args[0])
	}
	duration = time.Now().Sub(streamingStartTime)
	if hadErrors {
		err = fmt.Errorf("Execution of one or more stanzas failed")
		mi.Log("WARN", "Input execution status=completed_with_errors duration_s=%.03f cnt_events=%d", duration.Seconds(), mi.cntDataEventsGeneratedTotal)
	} else {
		err = nil
		mi.Log("INFO", "Input execution status=succeeded duration_s=%.03f cnt_events=%d", duration.Seconds(), mi.cntDataEventsGeneratedTotal)
	}

	return err
}

func (mi *ModularInput) runValidation() error {
	mi.Log("DEBUG", `Starting argument validation`)

	if !mi.UseExternalValidation {
		mi.Log("WARN", "Invoked with --validate-arguments command-line arguments but configured to NOT use external validation. Skipping it.")
		return nil
	}
	if mi.UseExternalValidation && mi.Validate == nil {
		mi.Log("WARN", "Configured to use external validation, but no validation function was specified. Skipping it.")
		return nil
	}

	if err := mi.Validate(mi, &mi.stanzas[0]); err != nil {
		mi.Log("ERROR", `Validation of parameters for stanza="%s" status=failed error="%s"`, mi.stanzas[0].Name, err.Error())
		// Splunk specification requires to write the validation errors on STDOUT
		// See: https://docs.splunk.com/Documentation/SplunkCloud/8.1.2011/AdvancedDev/ModInputsScripts#Create_a_modular_input_script
		fmt.Printf("%s\n", err.Error())
		return err
	}

	mi.Log("INFO", `Validation of input parameters for stanza="%s" status=succeeded`, mi.stanzas[0].Name)
	return nil
}

// setupEventBasedInternalLogging configures logging to be performed through SplunkEvent events written to index=_internal instead of using plain text on standard-err.
// Before activating this, the user is informed with a WARN message on StdErr saying which source/sourcetype is being used for logging purposes from now on
// This function can only be invoked when an active configuration has been provided in input, so, when we start streaming events.
func (mi *ModularInput) setupEventBasedInternalLogging(stanza *Stanza) {
	if stanza != nil {
		inputSourcetype := "modinput:" + stanza.Scheme()
		mi.Log("INFO", `Logging using 'index=_internal sourcetype="%s" source="%s"`, inputSourcetype, stanza.Name)
		mi.internalLogEvent = &SplunkEvent{
			// NOT specifying Data and Host intentionally
			Time:       GetEpochNow(),
			Stanza:     stanza.Name,
			SourceType: inputSourcetype,
			Index:      "_internal",
			Source:     stanza.Name,
			Unbroken:   false,
			Done:       false,
		}
	} else {
		mi.Log("ERROR", "Function setupEventBasedInternalLogging() called without a stanza being specified, this is an error within the library")
	}
}

// getExampleConf returns a string containing a sample configuration
// for the modular input based on its definition
// this can help an user test a configuration within splunk's inputs.conf
func (mi *ModularInput) getExampleConf() string {
	var sb strings.Builder
	fmt.Fprint(&sb, "# Example configs for inputs.conf\n")
	fmt.Fprintf(&sb, "# %s\n", mi.Description)
	fmt.Fprintf(&sb, "[%s://name-of-input]\n", mi.StanzaName)
	for _, arg := range mi.Args {
		fmt.Fprintf(&sb, "# %s - %s\n", arg.Title, arg.Description)
		fmt.Fprintf(&sb, "%s = <%s>\n", arg.Name, arg.DataType)
	}
	fmt.Fprint(&sb, "# Standard input configurations\n")
	fmt.Fprint(&sb, "index = <index>\n")
	fmt.Fprint(&sb, "sourcetype = <sourcetype>\n")
	fmt.Fprint(&sb, "interval = <cron schedule>\n")
	return sb.String()
}

// getXMLScheme returns a string containing a XML-based description
// of the configuration parameters accepted by the modular input
// The XML format is documented at: https://docs.splunk.com/Documentation/Splunk/8.1.2/AdvancedDev/ModInputsScripts#Define_a_scheme_for_introspection
func (mi *ModularInput) getXMLScheme() (string, error) {
	// using the tecnique described at https://riptutorial.com/go/example/14194/marshaling-structs-with-private-fields//
	// in order to output streaming_mode, which otherwise would have to be publicly exported, which is unwanted.
	if scheme, err := xml.MarshalIndent(struct {
		XMLName               xml.Name `xml:"scheme"`
		Title                 string   `xml:"title"`
		Description           string   `xml:"description"`
		UseExternalValidation bool     `xml:"use_external_validation"`
		UseSingleInstance     bool     `xml:"use_single_instance"`
		//Adding a fixed StreamingMode, not present within the original structure
		StreamingMode string     `xml:"streaming_mode"`
		Args          []InputArg `xml:"endpoint>args>arg"`
	}{
		Title:                 mi.Title,
		Description:           mi.Description,
		UseExternalValidation: mi.UseExternalValidation,
		UseSingleInstance:     mi.UseSingleInstance,
		//Adding a fixed StreamingMode
		StreamingMode: "xml",
		Args:          mi.Args,
	}, "", "  "); err != nil {
		return "", err
	} else {
		return string(scheme), nil
	}
}
