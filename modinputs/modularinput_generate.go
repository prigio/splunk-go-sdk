package modinputs

import (
	"fmt"
	"strings"
)

// generateInputsSpec returns a string which can be used to define the alert action within the splunk configuration file README/inputs.conf.spec
func (mi *ModularInput) generateInputsSpec() string {
	buf := new(strings.Builder)
	// pre-growing the buffer to 512 bytes: this avoids doing this continuously when executing buf.WriteString()
	buf.Grow(512)

	fmt.Fprintf(buf, `**
** Configurations for modular input '%s' within README/inputs.conf.spec
** These configurations have been auto-generated
**
[%s://<name>]
`, mi.Title, mi.StanzaName)

	for _, arg := range mi.Args {
		fmt.Fprint(buf, arg.getInputsSpec())
	}
	return buf.String()
}

// generateExampleConf returns a string containing a sample configuration
// for the modular input based on its definition
// this can help an user test a configuration within splunk's inputs.conf
func (mi *ModularInput) generateExampleConf() string {
	var sb strings.Builder
	fmt.Fprint(&sb, "# Example configs for local/inputs.conf\n")
	fmt.Fprintf(&sb, "# %s\n", mi.Description)
	fmt.Fprintf(&sb, "[%s://name-of-input]\n", mi.StanzaName)

	for _, arg := range mi.Args {
		fmt.Fprintf(&sb, "# %s - %s\n", arg.Title, arg.Description)
		if arg.DefaultValue != "" {
			fmt.Fprintf(&sb, "# Default value: %s\n", arg.DefaultValue)
		}
		fmt.Fprintf(&sb, "%s = <%s>\n", arg.Name, arg.DataType)
	}
	fmt.Fprint(&sb, "# Standard input configurations\n")
	fmt.Fprint(&sb, "index = <index>\n")
	if mi.defaultSourcetype != "" {
		fmt.Fprintf(&sb, "sourcetype = %s\n", mi.defaultSourcetype)
	} else {
		fmt.Fprint(&sb, "sourcetype = <sourcetype>\n")
	}
	fmt.Fprint(&sb, "interval = <cron schedule>\n")
	return sb.String()
}

// generateAlertActionsConf returns a string which can be used to define the alert action within the splunk configuration file default/alert_actions.conf
func (mi *ModularInput) generateInputsConf() string {
	buf := new(strings.Builder)
	// pre-growing the buffer to 512 bytes: this avoids doing this continuously when executing buf.WriteString()
	buf.Grow(512)

	fmt.Fprintf(buf, `
## Configurations for modular input '%s' within default/inputs.conf
## These configurations have been auto-generated
##
## See: https://docs.splunk.com/Documentation/Splunk/latest/Admin/Inputsconf
[%s]
# %s
# %s
#
`, mi.Title, mi.StanzaName, mi.Title, mi.Description)

	if mi.GetDefaultSourcetype() != "" {
		fmt.Fprintf(buf, "sourcetype = %s\n", mi.GetDefaultSourcetype())
	}

	if mi.GetDefaultIndex() != "" {
		fmt.Fprintf(buf, "index = %s\n", mi.GetDefaultIndex())
	}
	fmt.Fprintln(buf, `# Whether or not Splunk software runs introspection on a modular input 
# scheme when you have disabled all of its associated scripts by using the 'disabled = 1' setting.
# If set to "true", Splunk software runs introspection on a modular input 
#   scheme even when you have disabled all the input scripts for the scheme.
# If set to "false", Splunk software does not run introspection on a modular
#   input scheme where you have disabled all scripts for the scheme.
# If introspection does not run for a scheme, then Splunk software does not 
#   register the modular input scripts that are associated with the scheme 
#   for execution and it is disabled completely.
# Splunk default: true
# See: https://docs.splunk.com/Documentation/Splunk/latest/Admin/Inputsconf
run_introspection = true`)

	fmt.Fprintln(buf, "")
	fmt.Fprint(buf, `
# Parameters specific for this modular input
#   these can be autogenerated by starting the input from the command line.
#
`)

	for _, arg := range mi.Args {
		fmt.Fprintln(buf, arg.getInputsConf())
	}

	return buf.String()
}

// generateDocumentation returns a markdown-formatted string describing the alert and its parameters
func (mi *ModularInput) generateDocumentation() string {
	buf := new(strings.Builder)
	// pre-growing the buffer to 512 bytes: this avoids doing this continuously when executing buf.WriteString()
	buf.Grow(512)

	fmt.Fprintf(buf, `# Modular input "%s"

%s

`, mi.Title, mi.Description)
	if mi.Documentation != "" {
		fmt.Fprintln(buf, mi.Documentation)
	}

	fmt.Fprint(buf, `
## Configuration parameters

The following describes the parameters which an end user can setup using the inputs UI or the inputs.conf configuration file.

`)
	for _, par := range mi.Args {
		fmt.Fprintln(buf, par.GenerateDocumentation())
	}

	fmt.Fprintf(buf, `

## Global parameters

Global parameters are set by administrators and are valid for all executions of the modular input.
They are set in a custom configuration file and stanza, as described in the following.

`)
	for _, par := range mi.globalParams {
		fmt.Fprintln(buf, par.GenerateDocumentation())
	}

	fmt.Fprintf(buf, `

## Troubleshooting

The following indicates ways to troubleshoot functionality of the modular input.

Each execution of the modular input generates a random "runId" which is then written alongside all the emitted logs.

### Logs
The modular input logs its own logs to Splunk using the same method used to emit collected data. 
They are written in XML-format to STDOUT. Splunk indexes these logs within:

    index=_internal sourcetype="%s"

### Interactive execution

You can run the modular input from the command-line by invoking it with the appropriate command-line switch. Execute './<filename> -h' for more information

### Common issues

TBD.

`, mi.getLoggingSourcetype())

	return buf.String()
}

func (mi *ModularInput) generateAdHocConfigSpecs() string {
	var paramsByFileAndStanza map[string]map[string][]string = make(map[string]map[string][]string)

	for _, p := range mi.globalParams {
		confFile, stanza, _ := p.GetConfigDefinition()

		if !strings.HasSuffix(confFile, ".conf") {
			confFile = confFile + ".conf"
		}
		if _, found := paramsByFileAndStanza[confFile]; !found {
			paramsByFileAndStanza[confFile] = make(map[string][]string)
			paramsByFileAndStanza[confFile][stanza] = make([]string, 0)
		}
		if _, found := paramsByFileAndStanza[confFile][stanza]; !found {
			paramsByFileAndStanza[confFile][stanza] = make([]string, 0)
		}
		paramsByFileAndStanza[confFile][stanza] = append(paramsByFileAndStanza[confFile][stanza], p.GenerateSpec(""))
	}

	buf := new(strings.Builder)

	fmt.Fprintf(buf, `
** Specification for custom configuration files for modular input '%s' [%s]
** These specs have been auto-generated
`, mi.Title, mi.StanzaName)

	for file, stanzas := range paramsByFileAndStanza {
		fmt.Fprintf(buf, `
**
** File: 'README/%s.spec'
**
`, file)
		for stanza, paramSpecs := range stanzas {
			fmt.Fprintf(buf, "[%s]\n", stanza)
			for _, specString := range paramSpecs {
				fmt.Fprintln(buf, specString)
			}

		}
		fmt.Fprintln(buf, "")
	}
	return buf.String()
}

func (mi *ModularInput) generateAdHocConfigConfs() string {
	var paramsByFileAndStanza map[string]map[string][]string = make(map[string]map[string][]string)

	for _, p := range mi.globalParams {
		confFile, stanza, _ := p.GetConfigDefinition()
		if !strings.HasSuffix(confFile, ".conf") {
			confFile = confFile + ".conf"
		}
		if _, found := paramsByFileAndStanza[confFile]; !found {
			paramsByFileAndStanza[confFile] = make(map[string][]string)
			paramsByFileAndStanza[confFile][stanza] = make([]string, 0)
		}
		if _, found := paramsByFileAndStanza[confFile][stanza]; !found {
			paramsByFileAndStanza[confFile][stanza] = make([]string, 0)
		}
		paramsByFileAndStanza[confFile][stanza] = append(paramsByFileAndStanza[confFile][stanza], p.GenerateConf(""))
	}

	buf := new(strings.Builder)

	fmt.Fprintf(buf, `
## Configurations for custom configuration files for modular input '%s' [%s]
## These configurations have been auto-generated
`, mi.Title, mi.StanzaName)

	for file, stanzas := range paramsByFileAndStanza {
		fmt.Fprintf(buf, `
##
## File: 'default/%s'
##
`, file)
		for stanza, paramSpecs := range stanzas {
			fmt.Fprintf(buf, "[%s]\n", stanza)
			for _, specString := range paramSpecs {
				fmt.Fprintln(buf, specString)
			}

		}
		fmt.Fprintln(buf, "")
	}
	return buf.String()
}
